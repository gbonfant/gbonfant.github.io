<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Gus Bonfant]]></title>
  <link href="http://www.gbonfant.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://www.gbonfant.com/"/>
  <updated>2014-07-18T10:34:58+02:00</updated>
  <id>http://www.gbonfant.com/</id>
  <author>
    <name><![CDATA[Gus Bonfant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Responding to scope changes with controller as syntax]]></title>
    <link href="http://www.gbonfant.com/blog/responding-to-scope-changes-with-controller-as-syntax/"/>
    <updated>2014-07-11T14:51:50+02:00</updated>
    <id>http://www.gbonfant.com/blog/responding-to-scope-changes-with-controller-as-syntax</id>
    <content type="html"><![CDATA[<p>Before AngularJS 1.2 we used to bind our data models to the <code>$scope</code> object in a controller. I find this confusing as the use  of <code>scope</code> across my angular code looked like some dark magic.</p>

<p>Starting on <a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#115-triangle-squarification-2013-05-22">1.1.5</a> the <em>controller as</em> syntax was introduced, this allowed us to declare our controllers as plain javascript objects, such as:</p>

<p><code>javascript
myApp.controller('PersonController', function() {
  this.name = 'James';
});
</code></p>

<p>I liked this approach but it introduced an annoyance: watching scope changes didn&rsquo;t work anymore.</p>

<p>```javascript
myApp.controller(&lsquo;PersonController&rsquo;, [&lsquo;$scope&rsquo;, &lsquo;NotificationFactory&rsquo;, function($scope, NotificationFactory) {
  this.name          = &lsquo;James&rsquo;;
  this.notifications = NotificationFactory;</p>

<p>  $scope.watch(&lsquo;notifications&rsquo;, function(newValue, oldValue) {</p>

<pre><code>console.log('This does not work');
</code></pre>

<p>  });
}]);
```</p>

<!-- more -->


<p>After digging in angular&rsquo;s still confusing and terse <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope">documentation</a> I realised that you can pass a function as a listener argument to <code>$watch</code>, meaning that after properly binding our current context we could watch on our controller&rsquo;s object like so:</p>

<p>```javascript
myApp.controller(&lsquo;PersonController&rsquo;, [&lsquo;$scope&rsquo;, &lsquo;NotificationFactory&rsquo;, function($scope, NotificationFactory) {
  this.name          = &lsquo;James&rsquo;;
  this.notifications = NotificationFactory;</p>

<p>  $scope.watch(angular.bind(this, function() {</p>

<pre><code>return this.notifications;
</code></pre>

<p>  }), function(newValue, oldValue) {</p>

<pre><code>// This does work!
console.log(newValue, oldValue);
</code></pre>

<p>  });
}]);
```</p>

<p>Although this approach works it does not look elegant enough for such a behemoth of a framework. The amount of <a href="https://github.com/allaud/quick-ng-repeat">hacks</a> and <a href="http://stackoverflow.com/questions/15666048/angular-js-service-vs-provider-vs-factory">patterns</a> you sometimes need to apply in order to accomplish a relatively simple task is making me reconsidering angular in favour of more elegant and more performant <a href="http://facebook.github.io/react/">alternatives</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Execute a function on ng-repeat done]]></title>
    <link href="http://www.gbonfant.com/blog/execute-function-on-ng-repeat-done/"/>
    <updated>2013-08-25T21:58:05+02:00</updated>
    <id>http://www.gbonfant.com/blog/execute-function-on-ng-repeat-done</id>
    <content type="html"><![CDATA[<p>ngRepeat is one of Angular&rsquo;s most powerful directives and in most cases <em>it just works</em>, however there are times when I find myself wanting to update the DOM or execute a function as soon as the directive has finished its job.</p>

<p>Thanks to Angular&rsquo;s <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$destroy">$destroy()</a> I can create a custom directive to accomplish such effect.</p>

<p>```javascript
var app = angular.module(&lsquo;app&rsquo;, []);</p>

<p>app.directive(&lsquo;repeatDone&rsquo;, function() {
  return function(scope, element, attrs) {</p>

<pre><code>element.bind('$destroy', function(event) {
  if (scope.$last) {
    scope.$eval(attrs.repeatDone);
  }
});
</code></pre>

<p>  };
});
<code>`
By simply calling our directive along with</code>ng-repeat`` we can then execute our function as soon as the iteration is finished.</p>

<p>```html</p>

<div ng-repeat="item in model.items" repeat-done="foo()"></div>


<p>```</p>
]]></content>
  </entry>
  
</feed>
