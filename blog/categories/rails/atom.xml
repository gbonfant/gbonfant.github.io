<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Gus Bonfant]]></title>
  <link href="http://www.gbonfant.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.gbonfant.com/"/>
  <updated>2014-07-16T15:01:46+02:00</updated>
  <id>http://www.gbonfant.com/</id>
  <author>
    <name><![CDATA[Gus Bonfant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Set-up log level for specific exceptions]]></title>
    <link href="http://www.gbonfant.com/blog/set-up-log-level-specific-exceptions/"/>
    <updated>2013-08-19T21:08:49+02:00</updated>
    <id>http://www.gbonfant.com/blog/set-up-log-level-specific-exceptions</id>
    <content type="html"><![CDATA[<p>It seems to me that in the Rails world logging is an afterthought, something that can be easily taken care of via 3rd party services, not surprising considering how inexpensive, robust and easy to setup they are.</p>

<p>However, if you are manually keeping track of your logs with something like <a href="http://graylog2.org">graylog</a> finding any useful, straightforward information about logging in Rails can be daunting. So without any straightforward answer as to how to set a warn level for all those pesky 404 errors that were polluting our logs I decided to peek into Rails' internals. <a href="http://api.rubyonrails.org/classes/ActionDispatch/DebugExceptions.html">ActionDispatch::DebugExceptions</a> is a simple piece of middleware in charge of logging exceptions, upon further inspection I stumbled upon <code>log_error</code>.</p>

<p>```ruby
def log_error(env, wrapper)
  logger = logger(env)</p>

<p>  return unless logger</p>

<p>  exception = wrapper.exception</p>

<p>  trace = wrapper.application_trace
  trace = wrapper.framework_trace if trace.empty?</p>

<p>  ActiveSupport::Deprecation.silence do</p>

<pre><code># string manipulation code ...
logger.fatal("#{message}\n\n")
</code></pre>

<p>  end
end
```</p>

<p>It looks like <code>log_error</code> is logging every exception as fatal, this is exactly the behaviour I want to modify.</p>

<p>```ruby
class ActionDispatch::DebugExceptions
  def log_error(env, wrapper)</p>

<pre><code>return if wrapper.exception.is_a? ActionController::RoutingError

super
</code></pre>

<p>  end
end
```</p>

<p>I could as well override the method and add my own logic to it, for instance if I wanted to add a conditional, like so:</p>

<p>```ruby
def log_error(env, wrapper)
  # &hellip;
  if exception.is_a? ActionController::RoutingError</p>

<pre><code>logger.warn("#{message}\n\n")
</code></pre>

<p>  else</p>

<pre><code>logger.fatal("#{message}\n\n")
</code></pre>

<p> end
```</p>

<p>Middleware code is a joy to read and a great reminder that our code should be simple, lean and understandable.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Assigning date attributes without ActiveRecord]]></title>
    <link href="http://www.gbonfant.com/blog/assigning-date-attributes-without-active-record/"/>
    <updated>2013-05-14T16:13:26+02:00</updated>
    <id>http://www.gbonfant.com/blog/assigning-date-attributes-without-active-record</id>
    <content type="html"><![CDATA[<p>When straying away from &ldquo;the rails path&rdquo; we may find ourselves missing some nifty functionality the Rails modules provide us.</p>

<p>The most ubiquitous of those, ActiveRecord, is without a doubt a behemont of nifty functionalities, in this case seemingly instantiating and assigning date object to our models date attributes is a feature we give for granted.</p>

<p>However, if you are building Rails applications without ActiveRecord you might find yourself in a predicament when submitting a form with dates.</p>

<p>Assuming the following class:</p>

<p>```ruby
class Person &lt; BaseModel
  # For the sake of simplicity, BaseModel will add all the boilerplate
  # needed for making our class behave like an AR model class.
  attr_accessor :name, :birth_date</p>

<p>  def initialize(attributes = nil)</p>

<pre><code>super
</code></pre>

<p>  end
end
```</p>

<p>When submitting a form with the following parameters, <code>name</code> will be automatically assigned but <code>birth_date</code> won&rsquo;t.</p>

<p><code>javascript
{
  "name": "James Bond",
  "birth_date(3i)": "11",
  "birth_date(2i)": "11",
  "birth_date(1i)": "1920"
}
</code></p>

<p>The reason is simple, neither of the remaining parameters are attributes of our class. On ActiveRecord land, however, the remaining parameters will magically be assigned to our class attribute due to <code>assign_attribute</code> method call, which automatically assigns multi parameter attributes. This works by iterating over the passed attributes, selecting those that are of the type multi parameter, extract their values and assign them to a new hash which will ultimately be assigned to the parent class.</p>

<p>By poking into ActiveRecord&rsquo;s internals we can extract this logic into our own method:</p>

<p>```ruby
class Person &lt; BaseModel
  attr_accessor :name, :birth_date</p>

<p>  def initialize(attributes = nil)</p>

<pre><code>super

assign_dates(attributes) if attributes
</code></pre>

<p>  end</p>

<p>  protected</p>

<p>  def assign_dates(attributes)</p>

<pre><code>new_attributes            = attributes.stringify_keys
multiparameter_attributes = extract_multiparameter_attributes(new_attributes)

multiparameter_attributes.each do |multiparameter_attribute, values_hash|
  set_values = (1..3).collect{ |position| values_hash[position].to_i }

  self.send("#{multiparameter_attribute}=", Date.new(*set_values))
end
</code></pre>

<p>  end</p>

<p>  def extract_multiparameter_attributes(new_attributes)</p>

<pre><code>multiparameter_attributes = []

new_attributes.each do |k, v|
  if k.include?('(')
    multiparameter_attributes &lt;&lt; [k, v]
  end
end

extract_attributes(multiparameter_attributes)
</code></pre>

<p>  end</p>

<p>  def extract_attributes(pairs)</p>

<pre><code>attributes = {}

pairs.each do |pair|
  multiparameter_name, value = pair
  attribute_name             = multiparameter_name.split('(').first
  attributes[attribute_name] = {} unless attributes.include?(attribute_name)

  attributes[attribute_name][find_parameter_position(multiparameter_name)] ||= value
end

attributes
</code></pre>

<p>  end</p>

<p>  def find_parameter_position(multiparameter_name)</p>

<pre><code>multiparameter_name.scan(/\(([0-9]*).*\)/).first.first.to_i
</code></pre>

<p>  end
end
```</p>

<p>Diving into ActiveRecord&rsquo;s source is a rewarding exercise that greatly helps to understand the &ldquo;magic&rdquo; behind Rails nifty features.</p>

<p><em>Update:</em> It looks like this functionality will get extracted into ActiveModel for use by non-AR classes in 4.2 â€“ <a href="https://github.com/rails/rails/pull/8189">https://github.com/rails/rails/pull/8189</a></p>
]]></content>
  </entry>
  
</feed>
